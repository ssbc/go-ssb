// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"context"
	"sync"

	"go.cryptoscope.co/luigi"
	"go.cryptoscope.co/muxrpc"
	"go.cryptoscope.co/ssb"
)

type FakeWantManager struct {
	AllWantsStub        func() []ssb.BlobWant
	allWantsMutex       sync.RWMutex
	allWantsArgsForCall []struct {
	}
	allWantsReturns struct {
		result1 []ssb.BlobWant
	}
	allWantsReturnsOnCall map[int]struct {
		result1 []ssb.BlobWant
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CreateWantsStub        func(context.Context, luigi.Sink, muxrpc.Endpoint) luigi.Sink
	createWantsMutex       sync.RWMutex
	createWantsArgsForCall []struct {
		arg1 context.Context
		arg2 luigi.Sink
		arg3 muxrpc.Endpoint
	}
	createWantsReturns struct {
		result1 luigi.Sink
	}
	createWantsReturnsOnCall map[int]struct {
		result1 luigi.Sink
	}
	RegisterStub        func(luigi.Sink) func()
	registerMutex       sync.RWMutex
	registerArgsForCall []struct {
		arg1 luigi.Sink
	}
	registerReturns struct {
		result1 func()
	}
	registerReturnsOnCall map[int]struct {
		result1 func()
	}
	WantStub        func(*ssb.BlobRef) error
	wantMutex       sync.RWMutex
	wantArgsForCall []struct {
		arg1 *ssb.BlobRef
	}
	wantReturns struct {
		result1 error
	}
	wantReturnsOnCall map[int]struct {
		result1 error
	}
	WantWithDistStub        func(*ssb.BlobRef, int64) error
	wantWithDistMutex       sync.RWMutex
	wantWithDistArgsForCall []struct {
		arg1 *ssb.BlobRef
		arg2 int64
	}
	wantWithDistReturns struct {
		result1 error
	}
	wantWithDistReturnsOnCall map[int]struct {
		result1 error
	}
	WantsStub        func(*ssb.BlobRef) bool
	wantsMutex       sync.RWMutex
	wantsArgsForCall []struct {
		arg1 *ssb.BlobRef
	}
	wantsReturns struct {
		result1 bool
	}
	wantsReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWantManager) AllWants() []ssb.BlobWant {
	fake.allWantsMutex.Lock()
	ret, specificReturn := fake.allWantsReturnsOnCall[len(fake.allWantsArgsForCall)]
	fake.allWantsArgsForCall = append(fake.allWantsArgsForCall, struct {
	}{})
	fake.recordInvocation("AllWants", []interface{}{})
	fake.allWantsMutex.Unlock()
	if fake.AllWantsStub != nil {
		return fake.AllWantsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.allWantsReturns
	return fakeReturns.result1
}

func (fake *FakeWantManager) AllWantsCallCount() int {
	fake.allWantsMutex.RLock()
	defer fake.allWantsMutex.RUnlock()
	return len(fake.allWantsArgsForCall)
}

func (fake *FakeWantManager) AllWantsCalls(stub func() []ssb.BlobWant) {
	fake.allWantsMutex.Lock()
	defer fake.allWantsMutex.Unlock()
	fake.AllWantsStub = stub
}

func (fake *FakeWantManager) AllWantsReturns(result1 []ssb.BlobWant) {
	fake.allWantsMutex.Lock()
	defer fake.allWantsMutex.Unlock()
	fake.AllWantsStub = nil
	fake.allWantsReturns = struct {
		result1 []ssb.BlobWant
	}{result1}
}

func (fake *FakeWantManager) AllWantsReturnsOnCall(i int, result1 []ssb.BlobWant) {
	fake.allWantsMutex.Lock()
	defer fake.allWantsMutex.Unlock()
	fake.AllWantsStub = nil
	if fake.allWantsReturnsOnCall == nil {
		fake.allWantsReturnsOnCall = make(map[int]struct {
			result1 []ssb.BlobWant
		})
	}
	fake.allWantsReturnsOnCall[i] = struct {
		result1 []ssb.BlobWant
	}{result1}
}

func (fake *FakeWantManager) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeReturns
	return fakeReturns.result1
}

func (fake *FakeWantManager) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeWantManager) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeWantManager) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWantManager) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWantManager) CreateWants(arg1 context.Context, arg2 luigi.Sink, arg3 muxrpc.Endpoint) luigi.Sink {
	fake.createWantsMutex.Lock()
	ret, specificReturn := fake.createWantsReturnsOnCall[len(fake.createWantsArgsForCall)]
	fake.createWantsArgsForCall = append(fake.createWantsArgsForCall, struct {
		arg1 context.Context
		arg2 luigi.Sink
		arg3 muxrpc.Endpoint
	}{arg1, arg2, arg3})
	fake.recordInvocation("CreateWants", []interface{}{arg1, arg2, arg3})
	fake.createWantsMutex.Unlock()
	if fake.CreateWantsStub != nil {
		return fake.CreateWantsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createWantsReturns
	return fakeReturns.result1
}

func (fake *FakeWantManager) CreateWantsCallCount() int {
	fake.createWantsMutex.RLock()
	defer fake.createWantsMutex.RUnlock()
	return len(fake.createWantsArgsForCall)
}

func (fake *FakeWantManager) CreateWantsCalls(stub func(context.Context, luigi.Sink, muxrpc.Endpoint) luigi.Sink) {
	fake.createWantsMutex.Lock()
	defer fake.createWantsMutex.Unlock()
	fake.CreateWantsStub = stub
}

func (fake *FakeWantManager) CreateWantsArgsForCall(i int) (context.Context, luigi.Sink, muxrpc.Endpoint) {
	fake.createWantsMutex.RLock()
	defer fake.createWantsMutex.RUnlock()
	argsForCall := fake.createWantsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWantManager) CreateWantsReturns(result1 luigi.Sink) {
	fake.createWantsMutex.Lock()
	defer fake.createWantsMutex.Unlock()
	fake.CreateWantsStub = nil
	fake.createWantsReturns = struct {
		result1 luigi.Sink
	}{result1}
}

func (fake *FakeWantManager) CreateWantsReturnsOnCall(i int, result1 luigi.Sink) {
	fake.createWantsMutex.Lock()
	defer fake.createWantsMutex.Unlock()
	fake.CreateWantsStub = nil
	if fake.createWantsReturnsOnCall == nil {
		fake.createWantsReturnsOnCall = make(map[int]struct {
			result1 luigi.Sink
		})
	}
	fake.createWantsReturnsOnCall[i] = struct {
		result1 luigi.Sink
	}{result1}
}

func (fake *FakeWantManager) Register(arg1 luigi.Sink) func() {
	fake.registerMutex.Lock()
	ret, specificReturn := fake.registerReturnsOnCall[len(fake.registerArgsForCall)]
	fake.registerArgsForCall = append(fake.registerArgsForCall, struct {
		arg1 luigi.Sink
	}{arg1})
	fake.recordInvocation("Register", []interface{}{arg1})
	fake.registerMutex.Unlock()
	if fake.RegisterStub != nil {
		return fake.RegisterStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.registerReturns
	return fakeReturns.result1
}

func (fake *FakeWantManager) RegisterCallCount() int {
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	return len(fake.registerArgsForCall)
}

func (fake *FakeWantManager) RegisterCalls(stub func(luigi.Sink) func()) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = stub
}

func (fake *FakeWantManager) RegisterArgsForCall(i int) luigi.Sink {
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	argsForCall := fake.registerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWantManager) RegisterReturns(result1 func()) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = nil
	fake.registerReturns = struct {
		result1 func()
	}{result1}
}

func (fake *FakeWantManager) RegisterReturnsOnCall(i int, result1 func()) {
	fake.registerMutex.Lock()
	defer fake.registerMutex.Unlock()
	fake.RegisterStub = nil
	if fake.registerReturnsOnCall == nil {
		fake.registerReturnsOnCall = make(map[int]struct {
			result1 func()
		})
	}
	fake.registerReturnsOnCall[i] = struct {
		result1 func()
	}{result1}
}

func (fake *FakeWantManager) Want(arg1 *ssb.BlobRef) error {
	fake.wantMutex.Lock()
	ret, specificReturn := fake.wantReturnsOnCall[len(fake.wantArgsForCall)]
	fake.wantArgsForCall = append(fake.wantArgsForCall, struct {
		arg1 *ssb.BlobRef
	}{arg1})
	fake.recordInvocation("Want", []interface{}{arg1})
	fake.wantMutex.Unlock()
	if fake.WantStub != nil {
		return fake.WantStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.wantReturns
	return fakeReturns.result1
}

func (fake *FakeWantManager) WantCallCount() int {
	fake.wantMutex.RLock()
	defer fake.wantMutex.RUnlock()
	return len(fake.wantArgsForCall)
}

func (fake *FakeWantManager) WantCalls(stub func(*ssb.BlobRef) error) {
	fake.wantMutex.Lock()
	defer fake.wantMutex.Unlock()
	fake.WantStub = stub
}

func (fake *FakeWantManager) WantArgsForCall(i int) *ssb.BlobRef {
	fake.wantMutex.RLock()
	defer fake.wantMutex.RUnlock()
	argsForCall := fake.wantArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWantManager) WantReturns(result1 error) {
	fake.wantMutex.Lock()
	defer fake.wantMutex.Unlock()
	fake.WantStub = nil
	fake.wantReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWantManager) WantReturnsOnCall(i int, result1 error) {
	fake.wantMutex.Lock()
	defer fake.wantMutex.Unlock()
	fake.WantStub = nil
	if fake.wantReturnsOnCall == nil {
		fake.wantReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wantReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWantManager) WantWithDist(arg1 *ssb.BlobRef, arg2 int64) error {
	fake.wantWithDistMutex.Lock()
	ret, specificReturn := fake.wantWithDistReturnsOnCall[len(fake.wantWithDistArgsForCall)]
	fake.wantWithDistArgsForCall = append(fake.wantWithDistArgsForCall, struct {
		arg1 *ssb.BlobRef
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("WantWithDist", []interface{}{arg1, arg2})
	fake.wantWithDistMutex.Unlock()
	if fake.WantWithDistStub != nil {
		return fake.WantWithDistStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.wantWithDistReturns
	return fakeReturns.result1
}

func (fake *FakeWantManager) WantWithDistCallCount() int {
	fake.wantWithDistMutex.RLock()
	defer fake.wantWithDistMutex.RUnlock()
	return len(fake.wantWithDistArgsForCall)
}

func (fake *FakeWantManager) WantWithDistCalls(stub func(*ssb.BlobRef, int64) error) {
	fake.wantWithDistMutex.Lock()
	defer fake.wantWithDistMutex.Unlock()
	fake.WantWithDistStub = stub
}

func (fake *FakeWantManager) WantWithDistArgsForCall(i int) (*ssb.BlobRef, int64) {
	fake.wantWithDistMutex.RLock()
	defer fake.wantWithDistMutex.RUnlock()
	argsForCall := fake.wantWithDistArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWantManager) WantWithDistReturns(result1 error) {
	fake.wantWithDistMutex.Lock()
	defer fake.wantWithDistMutex.Unlock()
	fake.WantWithDistStub = nil
	fake.wantWithDistReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWantManager) WantWithDistReturnsOnCall(i int, result1 error) {
	fake.wantWithDistMutex.Lock()
	defer fake.wantWithDistMutex.Unlock()
	fake.WantWithDistStub = nil
	if fake.wantWithDistReturnsOnCall == nil {
		fake.wantWithDistReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.wantWithDistReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWantManager) Wants(arg1 *ssb.BlobRef) bool {
	fake.wantsMutex.Lock()
	ret, specificReturn := fake.wantsReturnsOnCall[len(fake.wantsArgsForCall)]
	fake.wantsArgsForCall = append(fake.wantsArgsForCall, struct {
		arg1 *ssb.BlobRef
	}{arg1})
	fake.recordInvocation("Wants", []interface{}{arg1})
	fake.wantsMutex.Unlock()
	if fake.WantsStub != nil {
		return fake.WantsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.wantsReturns
	return fakeReturns.result1
}

func (fake *FakeWantManager) WantsCallCount() int {
	fake.wantsMutex.RLock()
	defer fake.wantsMutex.RUnlock()
	return len(fake.wantsArgsForCall)
}

func (fake *FakeWantManager) WantsCalls(stub func(*ssb.BlobRef) bool) {
	fake.wantsMutex.Lock()
	defer fake.wantsMutex.Unlock()
	fake.WantsStub = stub
}

func (fake *FakeWantManager) WantsArgsForCall(i int) *ssb.BlobRef {
	fake.wantsMutex.RLock()
	defer fake.wantsMutex.RUnlock()
	argsForCall := fake.wantsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWantManager) WantsReturns(result1 bool) {
	fake.wantsMutex.Lock()
	defer fake.wantsMutex.Unlock()
	fake.WantsStub = nil
	fake.wantsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWantManager) WantsReturnsOnCall(i int, result1 bool) {
	fake.wantsMutex.Lock()
	defer fake.wantsMutex.Unlock()
	fake.WantsStub = nil
	if fake.wantsReturnsOnCall == nil {
		fake.wantsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.wantsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWantManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allWantsMutex.RLock()
	defer fake.allWantsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createWantsMutex.RLock()
	defer fake.createWantsMutex.RUnlock()
	fake.registerMutex.RLock()
	defer fake.registerMutex.RUnlock()
	fake.wantMutex.RLock()
	defer fake.wantMutex.RUnlock()
	fake.wantWithDistMutex.RLock()
	defer fake.wantWithDistMutex.RUnlock()
	fake.wantsMutex.RLock()
	defer fake.wantsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWantManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ssb.WantManager = new(FakeWantManager)
